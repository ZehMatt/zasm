  #pragma once
  
  #include "operand.hpp"
  
  #include <array>
  #include <cassert>
  #include <zasm/core/enumflags.hpp>
  #include <zasm/core/packed.hpp>
  
  namespace zasm
  {
      class Instruction
      {
          static constexpr size_t kMaxOperands = 10;
  
      public:
          enum class Mnemonic : uint16_t;
          enum class Encoding : uint8_t;
          enum class Attribs : uint16_t;
          enum class Category : uint8_t;
  
          using Length = uint8_t;
          using OperandCount = uint8_t;
          using Operands = std::array<Operand, kMaxOperands>;
  
          using OperandsAccess = Packed<uint32_t, Operand::Access, 3>;
          using OperandsVisibility = Packed<uint32_t, Operand::Visibility, 3>;
  
          struct CPUFlags
          {
              uint32_t read;
              uint32_t write;
              uint32_t undefined;
          };
  
      private:
          OperandsAccess _access{};
          OperandsVisibility _opsVisibility{};
          Operands _operands{};
          CPUFlags _cpuFlags{};
          Mnemonic _mnemonic{};
          Attribs _attribs{};
          OperandCount _opCount{};
          Category _category{};
          Length _length{};
          bool _metaDataValid{};
  
      public:
          constexpr Instruction() noexcept = default;
          constexpr Instruction(
              Attribs attribs, Mnemonic mnemonic, OperandCount opCount, const Operands& operands, const OperandsAccess& access,
              const OperandsVisibility& opsVisibility, const CPUFlags& flags, const Category& category,
              Length length = 0) noexcept
              : _operands{ operands }
              , _opCount{ opCount }
              , _mnemonic{ mnemonic }
              , _access{ access }
              , _opsVisibility{ opsVisibility }
              , _cpuFlags{ flags }
              , _category{ category }
              , _attribs{ attribs }
              , _length{ length }
              , _metaDataValid{ true }
          {
          }
  
          /// <summary>
          /// Returns true if the meta data provided for this instruction is currently valid.
          /// Mutating the Instruction via functions like setMnemonic, setOperand etc can invalidate the
          /// meta information about the instruction. Instructions from the Decoder or generated by the
          /// Assembler will usually hold valid meta data.
          /// If this function returns false then things like CPU flags and operand access are undefined and
          /// should not be used.
          /// </summary>
          /// <returns>True if the meta data is valid and accessible</returns>
          constexpr bool isMetaDataValid() const noexcept
          {
              return _metaDataValid;
          }
  
          /// <summary>
          /// Returns the architecture specific mnemonic for this instructions ex.: x86::Mnemonic::Mov
          /// </summary>
          constexpr Mnemonic getMnemonic() const noexcept
          {
              return _mnemonic;
          }
  
          /// <summary>
          /// Sets a new mnemonic for this instructions, this must be one of the architecture defined mnemonic
          /// ex.: x86::Mnemonic::Mov
          /// Modifying the mnemonic will also invalidate the meta data.
          /// </summary>
          /// <param name="mnemonic">New mnemonic</param>
          /// <returns>Instruction&</returns>
          template<typename T> constexpr Instruction& setMnemonic(T mnemonic)
          {
              if (_mnemonic != static_cast<Mnemonic>(mnemonic))
                  _metaDataValid = false;
  
              _mnemonic = static_cast<Mnemonic>(mnemonic);
  
              return *this;
          }
  
          /// <summary>
          /// Returns the architecture specific attributes this instruction currently has
          /// ex.: x86::Attribs::Lock
          /// </summary>
          /// <returns>Attribs</returns>
          constexpr Attribs getAttribs() const noexcept
          {
              return _attribs;
          }
  
          /// <summary>
          /// Returns true if the specified attribute is set.
          /// </summary>
          /// <param name="attrib">Attribute to check</param>
          /// <returns>True if set.</returns>
          template<typename T> constexpr bool hasAttrib(T attrib) const noexcept
          {
              static_assert(std::is_enum_v<T> || std::is_integral_v<T>, "Type must be integral or enum");
  
              return (static_cast<uint32_t>(_attribs) & static_cast<uint32_t>(attrib)) != 0u;
          }
  
          /// <summary>
          /// Adds new architecture specific attributes to the instruction
          /// ex.: x86::Attribs::Lock
          /// Modifying the attributes will also invalidate the meta data.
          /// </summary>
          /// <param name="attrib">Attributes to add</param>
          /// <returns>Instruction&</returns>
          template<typename T> constexpr Instruction& addAttribs(T attrib)
          {
              static_assert(std::is_enum_v<T> || std::is_integral_v<T>, "Type must be integral or enum");
  
              _metaDataValid = false;
              _attribs = static_cast<Attribs>(static_cast<uint32_t>(_attribs) | static_cast<uint32_t>(attrib));
  
              return *this;
          }
  
          /// <summary>
          /// Removes architecture specific attributes from the instruction
          /// ex.: x86::Attribs::Lock
          /// Modifying the attributes will also invalidate the meta data.
          /// </summary>
          /// <param name="attrib">Attributes to remove</param>
          /// <returns>Instruction&</returns>
          template<typename T> constexpr Instruction& removeAttribs(T attrib)
          {
              static_assert(std::is_enum_v<T> || std::is_integral_v<T>, "Type must be integral or enum");
  
              _metaDataValid = false;
              _attribs = static_cast<Attribs>(static_cast<uint32_t>(_attribs) & ~static_cast<uint32_t>(attrib));
  
              return *this;
          }
  
          constexpr Category getCategory() const noexcept
          {
              assert(_metaDataValid == true);
  
              return _category;
          }
  
          /// <summary>
          /// Returns the length of the instruction.
          /// Depending on the origin of the Instruction object this value can be one of three things
          /// 1. From decoder this is the length of the decoded data for this instruction.
          /// 2. From assembler this is the approximate length when encoded, this is not always accurate.
          /// 3. Temporary or mutated instructions will have undefined length in this case it will return 0.
          /// </summary>
          /// <returns>Length of instruction if available</returns>
          constexpr Length getLength() const noexcept
          {
              assert(_metaDataValid == true);
  
              if (!_metaDataValid)
                  return 0;
  
              return _length;
          }
  
          constexpr const Operands& getOperands() const noexcept
          {
              return _operands;
          }
  
          constexpr size_t getOperandCount() const noexcept
          {
              return _opCount;
          }
  
          template<size_t TIndex, typename T = Operand> constexpr const T& getOperand() const
          {
              if constexpr (std::is_same_v<T, Operand>)
              {
                  return std::get<TIndex>(_operands);
              }
              else
              {
                  auto& op = std::get<TIndex>(_operands);
                  return op.template get<T>();
              }
          }
  
          template<size_t TIndex, typename T = Operand> constexpr T& getOperand()
          {
              if constexpr (std::is_same_v<T, Operand>)
              {
                  return std::get<TIndex>(_operands);
              }
              else
              {
                  auto& op = std::get<TIndex>(_operands);
                  return op.template get<T>();
              }
          }
  
          template<typename T = Operand> constexpr const T& getOperand(size_t index) const
          {
              if constexpr (std::is_same_v<T, Operand>)
              {
                  return _operands[index];
              }
              else
              {
                  auto& op = _operands[index];
                  return op.template get<T>();
              }
          }
  
          template<typename T = Operand> constexpr T& getOperand(size_t index)
          {
              if constexpr (std::is_same_v<T, Operand>)
              {
                  return _operands[index];
              }
              else
              {
                  auto& op = _operands[index];
                  return op.template get<T>();
              }
          }
  
          template<typename T> constexpr const T* getOperandIf(size_t index) const noexcept
          {
              if (index >= _opCount || index >= _operands.size())
                  return nullptr;
  
              auto& op = _operands[index];
              return op.template getIf<T>();
          }
  
          template<typename T> constexpr T* getOperandIf(size_t index) noexcept
          {
              if (index >= _opCount || index >= _operands.size())
                  return nullptr;
  
              auto& op = _operands[index];
              return op.template getIf<T>();
          }
  
          constexpr Instruction& addOperand(const Operand& val) noexcept
          {
              assert(_opCount < _operands.size());
  
              if (_opCount < _operands.size())
              {
                  _metaDataValid = false;
                  _operands[_opCount] = val;
                  _opCount++;
              }
  
              return *this;
          }
  
          constexpr Instruction& setOperand(size_t index, const Operand& val) noexcept
          {
              assert(index < _opCount);
  
              if (index < _opCount)
              {
                  // Allow to keep the meta data valid if the operand type is the same.
                  if (val.getTypeIndex() != _operands[index].getTypeIndex())
                  {
                      _metaDataValid = false;
                  }
                  _operands[index] = val;
              }
  
              return *this;
          }
  
          constexpr const OperandsVisibility& getOperandsVisibility() const noexcept
          {
              return _opsVisibility;
          }
  
          constexpr const Operand::Visibility getOperandVisibility(size_t index) const noexcept
          {
              assert(_metaDataValid == true);
  
              if (index >= _opCount || !_metaDataValid)
                  return Operand::Visibility::Invalid;
  
              return _opsVisibility.get(index);
          }
  
          constexpr bool isOperandHidden(size_t index) const noexcept
          {
              assert(_metaDataValid == true);
  
              if (index >= _opCount)
                  return true;
  
              return getOperandVisibility(index) == Operand::Visibility::Hidden;
          }
  
          constexpr bool isOperandExplicit(size_t index) const noexcept
          {
              assert(_metaDataValid == true);
  
              if (index >= _opCount)
                  return false;
  
              return getOperandVisibility(index) == Operand::Visibility::Explicit;
          }
  
          constexpr bool isOperandImplicit(size_t index) const noexcept
          {
              assert(_metaDataValid == true);
  
              if (index >= _opCount)
                  return false;
  
              return getOperandVisibility(index) == Operand::Visibility::Implicit;
          }
  
          constexpr const Operand::Access getOperandAccess(size_t index) const noexcept
          {
              assert(_metaDataValid == true);
  
              if (index >= _opCount || !_metaDataValid)
                  return Operand::Access::None;
  
              return _access.get(index);
          }
  
          constexpr const OperandsAccess& getOperandsAccess() const noexcept
          {
              assert(_metaDataValid == true);
  
              return _access;
          }
  
          constexpr const CPUFlags& getCPUFlags() const noexcept
          {
              assert(_metaDataValid == true);
  
              return _cpuFlags;
          }
      };
  
  } // namespace zasm
